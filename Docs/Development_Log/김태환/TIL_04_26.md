### 라즈베리파이 포팅 순서

---

- Pi OS
    - Rasberry Pi OS (Legacy, 64-bit) release; 2024-03-12
    
- Pi Configuration
    - Interfaces 전부 on
    
- time 설정
    
    ```bash
    sudo ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime
    
    sudo date [현재 시간]
    
    EX.
    sudo date 042610182024.00
    ```
    
- apt 업데이트 및 vim 설치
    
    ```bash
    sudo apt-get update
    sudo apt-get upgrade -y
    sudo apt install vim
    ```
    
- UWB 라이브러리 git clone
    
    ```bash
    git clone https://github.com/pedestrian0423/DW1000_Raspi_Python_library.git
    ```
    

### SPI 통신 in DW1000

---

- DW1000으로 들어오는 SPI 옥텟 트랜잭션은 헤더 옥텟과 데이터 옥텟으로 구성해서 전송
- SPI CSn 핀에 LOW값이 들어가면 그 때 부터 시작, HIGH값이 들어가면 종료
- 즉, LOW값이 된 상태에서 들어오는 첫 번째 옥텟을 헤더 옥텟으로 판단함
- 헤더 옥텟
    - 1 ~ 3개로 구성됨
    - 7번 비트가 0이면 read, 1이면 write
    - 6번 비트는 0, sub옥텟이 있으면 1
    - 5 ~ 0번 비트는 레지스터 주소
    - write 모드면 뒤의 데이터 옥텟을 모두 DW1000의 레지스터 주소에 저장함
    - read 모드면 레지스터 주소에 저장된 값들을 데이터 옥텟에 저장함
- 데이터 옥텟
    - 레지스터 주소에 저장할 값 들어오는 옥텟을 순서대로 0번지 부터 저장
    - read 모드면 0을 보냄
    
- SPI 통신 테스트 코드 (수정 중)
    
    ```python
    import spidev
    import RPi.GPIO as GPIO
    
    spi = spidev.SpiDev()
    spi.open(0,0)
    spi.max_speed_hz = 1000000
    
    reg_address = 0x04
    _chipSelect = 8
    
    data = [0x02, 0x04, 0x06, 0x08]
    readData = [0,0,0,0]
    # spi interface 규칙
    # 7번 비트는 0 - read, 1 - write
    # 6번 비트는 0
    # 따라서, 5 ~ 0 번 비트 사이에서 레지스터 주소를 입력해야 함 -> 64개 주소 사용 가능 (0x00 ~ 0x3F 사이만 사용 가능)
    
    # 쓰기 명령을 수행할 때, reg_address와 7번 비트 on을 위해 0x80과 or 연산
    # 읽기를 하려면 그냥 보내면 됨
    # write = spi.xfer([reg_address | 0x80, 0x01, 0x23,0x45,0x67])
    
    # print(write)
    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)
    GPIO.setup(_chipSelect, GPIO.OUT)
    GPIO.output(_chipSelect, GPIO.HIGH)
    
    # cs LOW -> Head 옥텟 xfer -> data 옥텟 xfer -> cs HIGH
    
    # cs LOW
    GPIO.output(_chipSelect, GPIO.LOW)
    
    # head xfer
    spi.xfer([reg_address | 0x80])
    
    # data xfer
    for i in range(0, 4):
        spi.xfer([data[i]])
    
    # cs HIGH
    GPIO.output(_chipSelect, GPIO.HIGH)
    
    print("Writing Complete!\n")
    
    GPIO.output(_chipSelect, GPIO.LOW)
    
    spi.xfer([int(reg_address)])
    
    for i in range(0, 4):
        readData[i] = spi.xfer([0x00])
    
    GPIO.output(_chipSelect, GPIO.HIGH)
    
    print("reading Complete\n")
    
    for i in readData:
        print(i)
    ```