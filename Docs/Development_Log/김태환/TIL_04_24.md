### 일정

---

- ESP32로 우회

- Port : COM5
- Board : ESP 32 Dev Module

- 소스 코드 정리
    
    ```cpp
    void loop() {
      if (!sentAck && !receivedAck) {
        // check if inactive
        if (millis() - lastActivity > resetPeriod) {
          resetInactive();
        }
        return;
      }
      // continue on any success confirmation
      if (sentAck) {
        sentAck = false;
        DW1000Ng::startReceive();
      }
      if (receivedAck) {
        receivedAck = false;
        // get message and parse
        DW1000Ng::getReceivedData(data, LEN_DATA);
        byte msgId = data[0];
        if (msgId != expectedMsgId) {
          // unexpected message, start over again
          //Serial.print("Received wrong message # "); Serial.println(msgId);
          expectedMsgId = POLL_ACK;
          transmitPoll();
          return;
        }
        if (msgId == POLL_ACK) {
          timePollSent = DW1000Ng::getTransmitTimestamp();
          timePollAckReceived = DW1000Ng::getReceiveTimestamp();
          expectedMsgId = RANGE_REPORT;
          transmitRange();
          noteActivity();
        } else if (msgId == RANGE_REPORT) {
          expectedMsgId = POLL_ACK;
          float curRange;
          memcpy(&curRange, data + 1, 4);
          delay(100);
          transmitPoll();
          noteActivity();
        } else if (msgId == RANGE_FAILED) {
          expectedMsgId = POLL_ACK;
          transmitPoll();
          noteActivity();
        }
      }
    }
    ```
    
    - sentAck
        
        ```cpp
        volatile boolean sentAck = false;
        
        void handleSent() {
          // status change on sent success
          sentAck = true;
        }
        
        // 메시지를 전송하
        
        if (sentAck) {
            sentAck = false;
            DW1000Ng::startReceive();
          }
        ```
        
        - handleSent 동작 시 sentAck → true로 변경
        - sentAck true면 startReceive 수행
            
            ```cpp
            //hpp
            void startReceive(ReceiveMode mode = ReceiveMode::IMMEDIATE);
            
            //cpp
            constexpr uint16_t LEN_SYS_CTRL = 4;
            constexpr uint16_t SFCST_BIT = 0;
            constexpr uint16_t RXENAB_BIT = 8;
            constexpr uint16_t RXDLYS_BIT = 9;
            constexpr uint16_t NO_SUB = 0xFF;
            
            byte       _sysctrl[LEN_SYS_CTRL];
            
            void startReceive(ReceiveMode mode) {
            		memset(_sysctrl, 0, LEN_SYS_CTRL);
            		DW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);
            		if(mode == ReceiveMode::DELAYED)
            			DW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);
            		DW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);
            		_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);
            	}
            	
            ```
            
            - setbit
                
                ```cpp
                void setBit(byte data[], uint16_t n, uint16_t bit, boolean val) {
                		uint16_t idx;
                		uint8_t shift;
                		
                		idx = bit/8;
                		if(idx >= n) {
                			return; // TODO proper error handling: out of bounds
                		}
                		byte* targetByte = &data[idx];
                		shift = bit%8;
                		if(val) {
                			bitSet(*targetByte, shift);
                		} else {
                			bitClear(*targetByte, shift);
                		}
                	}
                ```
                
                - data의 target 위치에 bit추가/삭제
                
            - _writeBytesToRegister
                
                ```cpp
                void _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size) {
                			byte header[3];
                			uint8_t headerLen = 1;
                			
                			// TODO proper error handling: address out of bounds
                			// build SPI header
                			if(offset == NO_SUB) {
                				header[0] = WRITE | cmd;
                			} else {
                				header[0] = WRITE_SUB | cmd;
                				if(offset < 128) {
                					header[1] = (byte)offset;
                					headerLen++;
                				} else {
                					header[1] = RW_SUB_EXT | (byte)offset;
                					header[2] = (byte)(offset >> 7);
                					headerLen += 2;
                				}
                			}
                			
                			SPIporting::writeToSPI(_ss, headerLen, header, data_size, data);
                		}
                ```
                
        
        1. _sysctrl 초기화 (memset)
        2. 
        
    - receiveAck

- distance 관련
    
    ```cpp
    DW1000Ng::getReceivedData(data, LEN_DATA);
    
    timeRangeReceived = DW1000Ng::getReceiveTimestamp();
          expectedMsgId = POLL;
          if (!protocolFailed) {
              timePollSent = DW1000NgUtils::bytesAsValue(data + 1, LENGTH_TIMESTAMP);
              timePollAckReceived = DW1000NgUtils::bytesAsValue(data + 6, LENGTH_TIMESTAMP);
              timeRangeSent = DW1000NgUtils::bytesAsValue(data + 11, LENGTH_TIMESTAMP);
              // (re-)compute range as two-way ranging is done
              double distance = DW1000NgRanging::computeRangeAsymmetric(timePollSent,
                                                          timePollReceived, 
                                                          timePollAckSent, 
                                                          timePollAckReceived, 
                                                          timeRangeSent, 
                                                          timeRangeReceived);
              /* Apply simple bias correction */
              distance = DW1000NgRanging::correctRange(distance);
    ```
    
    - getReceivedData
        
        ```cpp
        void getReceivedData(byte data[], uint16_t n) {
        		if(n <= 0) {
        			return;
        		}
        		_readBytesFromRegister(RX_BUFFER, NO_SUB, data, n);
        	}
        ```
        
    
    - _readBytesFromRegister
        
        ```cpp
        void _readBytesFromRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size) {
        			byte header[3];
        			uint8_t headerLen = 1;
        			
        			// build SPI header
        			if(offset == NO_SUB) {
        				header[0] = READ | cmd;
        			} else {
        				header[0] = READ_SUB | cmd;
        				if(offset < 128) {
        					header[1] = (byte)offset;
        					headerLen++;
        				} else {
        					header[1] = RW_SUB_EXT | (byte)offset;
        					header[2] = (byte)(offset >> 7);
        					headerLen += 2;
        				}
        			}
        
        			SPIporting::readFromSPI(_ss, headerLen, header, data_size, data);
        		}
        ```
        
        - cmd 레지스터
        - SPIporting::readFromSPI
            
            ```cpp
            void readFromSPI(uint8_t slaveSelectPIN, uint8_t headerLen, byte header[], uint16_t dataLen, byte data[]){
            		_openSPI(slaveSelectPIN);
            		for(auto i = 0; i < headerLen; i++) {
            			_spi->transfer(header[i]); // send header
            		}
            		for(auto i = 0; i < dataLen; i++) {
            			data[i] = _spi->transfer(0x00); // read values
            		}
            		delayMicroseconds(5);
            		_closeSPI(slaveSelectPIN);
            	}
            ```
            
            - 
    
    - ㅇㅇ
        
        ```cpp
        uint64_t getTransmitTimestamp() {
        		byte data[LENGTH_TIMESTAMP];
        		memset(data, 0 , LENGTH_TIMESTAMP);
        		_readBytesFromRegister(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);
        		return DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);
        	}
        ```
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3a2f0137-34be-458f-8e4f-4919f6ce74ed/9a3364cb-f700-4cb0-b0ee-ab308c05add0/Untitled.png)
        
        - TX_TIME (0x17)은 DW1000 모듈의 레지스터 주소
        - 
    
    - DW1000NgRanging::computeRangeAsymmetric
        
        ```cpp
        double computeRangeAsymmetric(    
                                            uint64_t timePollSent, // 
                                            uint64_t timePollReceived, 
                                            uint64_t timePollAckSent, 
                                            uint64_t timePollAckReceived,
                                            uint64_t timeRangeSent,
                                            uint64_t timeRangeReceived
                                        )
            {
        			  // 인자 변수 저장
                uint32_t timePollSent_32 = static_cast<uint32_t>(timePollSent);
                uint32_t timePollReceived_32 = static_cast<uint32_t>(timePollReceived);
                uint32_t timePollAckSent_32 = static_cast<uint32_t>(timePollAckSent);
                uint32_t timePollAckReceived_32 = static_cast<uint32_t>(timePollAckReceived);
                uint32_t timeRangeSent_32 = static_cast<uint32_t>(timeRangeSent);
                uint32_t timeRangeReceived_32 = static_cast<uint32_t>(timeRangeReceived);
                
                
                double round1 = static_cast<double>(timePollAckReceived_32 - timePollSent_32);
                double reply1 = static_cast<double>(timePollAckSent_32 - timePollReceived_32);
                double round2 = static_cast<double>(timeRangeReceived_32 - timePollAckSent_32);
                double reply2 = static_cast<double>(timeRangeSent_32 - timePollAckReceived_32);
        
                int64_t tof_uwb = static_cast<int64_t>((round1 * round2 - reply1 * reply2) / (round1 + round2 + reply1 + reply2));
                double distance = tof_uwb * DISTANCE_OF_RADIO;
        
                return distance;
            }
        ```
        
        - 
        

### 주요 레지스터

---

- SYS_CTRL (0x0D)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3a2f0137-34be-458f-8e4f-4919f6ce74ed/67faee1d-dcc1-485a-a98f-4fddb7edf2f3/Untitled.png)
    
    - 각 bit의 on/off 상태에 따라 DW1000모듈의 상태를 제어
    - 
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3a2f0137-34be-458f-8e4f-4919f6ce74ed/d2d4bbcc-00df-4f80-b7f6-5f602d1bde1c/Untitled.png)
    

### 거리 측정

---

- 기준 모듈(Anchor)에서 신호 주기적으로 신호 전송
    - Responder 파일의 loop문에서 resetInactive 동작
    - 현재 MsgId를 POLL 상태로 변경하고 reciever() 동작
        - forceTRxOFF : SYS_CTRL 레지스터에 TRXOFF (0x06)번 비트 true로 변경 (Transmit을 안하겠다)
        - startReceive
            - SFCST_BIT : FCS (Frame Check Sequence)의 추가 여부 결정 (on - 추가 x, off - 추가 o)
            - RXDLYS_BIT : Receive 딜레이 추가 (ReceiveMode - Delayed가 켜졌을 경우 추가)
            - RXENAB_BIT : DW1000 수신기를 켜고 프리앰블 시퀀스 찾기 시작 (명령 후 16us 지연있음)
                - 프리앰블 - Transmit 되는 데이터 프레임의 앞 단 비트